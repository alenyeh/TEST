{"name":"Uitox","tagline":"API TEST","body":"#  版本控制（Revision control）是維護工程藍圖的標準作法，能追蹤工程藍圖從誕生一直到定案的過程。此外，版本控制也是一種軟體工程技巧，藉此能在軟體開發的過程中，確保由不同人所編輯的同一程式檔案都得到同步。\r\n為什麼使用版本控制？\r\n在軟體開發的過程中，程式碼每天不斷地產出，過程中會發生以下情況：\r\n\r\n    檔案被別人或自己覆蓋，甚至遺失\r\n    想復原前幾天寫的版本\r\n    想知道跟昨天寫的差在哪裡？\r\n    是誰改了這段程式碼，為什麼 ？\r\n    軟體發行，需要分成維護版跟開發版\r\n\r\n因此，我們希望有一種機制，能夠幫助我們：\r\n\r\n    可以隨時復原修改，回到之前的版本\r\n    多人協作時，不會把別人的東西蓋掉\r\n    保留修改歷史記錄，以供查詢\r\n    軟體發行時，可以方便管理不同版本\r\n\r\n## 定義\r\n\r\n一個版本控制系統 Version Control System (VCS)，通常有以下功能\r\n\r\n    建立 Repository，用來保存程式碼。\r\n    方便散佈程式給團隊，有效率協同開發\r\n    記錄誰改變什麼、在什麼時候、因為什麼原因\r\n    Branch(分支)，可因不同情境分開開發\r\n    Tag(標籤) 重要里程碑，以便參照\r\n\r\n那麼，什麼東西要存進 Repository 呢? 簡單來說，就是所有跑起來這個專案需要的東西，包括所有原始碼、範例設計檔、文件等等。而像是暫存檔、log 檔案、build files 等編譯後的產物則不需要存進 Repository。\r\n\r\n## ### 演進歷史\r\n\r\n版本控制系統從古至今，有幾種不同的模式：\r\n\r\n    Local VCS\r\n    Centralized VCS (Lock型，悲觀鎖定)\r\n    Centralized VCS(Merge型，樂觀鎖定)\r\n    Distributed VCS\r\n\r\n## Local VCS\r\n在本地端使用 copy paste 進行資料夾管理，例如 rcs。當然，缺點是無法協同開發。\r\nCentralized VCS (Lock型，悲觀鎖定)\r\n有一中央團隊共用的Repository，當有人要編輯某個檔案時，進行鎖定，以避免其他人也同時編輯造成衝突。\r\n雖然可以避免衝突，但是很不方便。其他人得排隊才能編輯檔案，萬一先取出的人寫很久或忘記 解除鎖定，後果將不堪設想。\r\nCentralized VCS(Merge型，樂觀鎖定)\r\n也是有一中央團隊共用的Repository，但是不用Lock來避免衝突，而是事後發現如果有別人也修改同一個檔案(稱作衝突)，再進行手動編修解決。有非常多的VCS屬於這一型，包括CVS, Subversion, Perforce等等。Centralized VCS 的共同缺點是做什麼事都要跟伺服器連線，會比較慢。另外也有單點故障的風險(Single point of failure)，只要伺服器壞掉，大家就不用作事了。\r\nDistributed VCS\r\n分散式版本控制系統讓本地端也擁有完整的Repository，就沒有上述集中式的問題，即使沒網路，照常可以 commit 和看 history log，也不用擔心server備份。例如 Git, Mercurial(Hg), Bazaar 等就是屬於分散式版本控制系統。\r\n若要說有什麼缺點，就是能力越大，功能就越複雜，一開始學習上會比較辛苦一點。\r\n\r\n## Git 名詞解釋\r\n物件模式(Object Mode)\r\nGit 中一共有四種模式 : Blob﹑Tree﹑Commit﹑Tag。\r\n\r\n    Blob: 只是用來儲存檔案內容，連檔案名字都沒有。\r\n    Tree: Tree 可以儲存文件名，同時也允許儲存一組檔案。所有内容以 Tree 或 Blob儲存，其中 Tree 對應於 UNIX 中的目錄，Blob 則大致對應於 nodes 或檔案内容。\r\n    Commit: Commit 為你保存了關於誰、何時以及為何保存了這些快照的訊息。\r\n    Tag: Tag 非常像一個 Commit ——包含一個標籤，一组數據，一個消息和一個指针。最主要的區别就是 Tag指向一個 Commit 而不是一個 tree。它就像是一個分支引用，但是不會變化——永遠指向同一個 Commit，僅僅是提供一個更加友好的名字。\r\n\r\n    Note : 可以把Blob 看作是檔案，Tree 看作是資料夾，Commit 看作是每次的更新，Tag 為大事件 \r\n\r\n## Git 參照 ( Git References )\r\n你可以執行像\r\n\r\n git log 1a410e \r\n\r\n這樣的指令來查看完整的紀錄，但是這樣你就要記得 1a410e 是你最後一次 commit，這樣才能在 commit history 中找到這些物件。你需要一個檔案來用一個簡單的名字來記錄這些 SHA-1 值，這樣你就可以用這些 pointer 而不是原來的 SHA-1 值去搜尋了。在 Git 中，我們稱之為 reference（references or refs），以下是 Git 中常用的 reference 介紹。\r\n\r\n    head: 是一個指向你當前所在分支的引用標示符號。\r\n    tag: tag 是一個物件也是一個引用，我們在之前已經做過了詳細的說明。\r\n    remote: 是一個標示符號指向你最後一次和伺服器的通訊的分支。\r\n    branch: 是一個指向每個分支最前面 commit 的指標，告訴使用者分支名稱。\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}